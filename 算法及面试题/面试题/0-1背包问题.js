/**
 * 题目：
 * 给你一个可装载重量为W的背包和N个物品，每个物品有
 * 重量和价值两个属性，其中第i个物品的重量为wt[i],
 * 价值为val[i]，现在让你用这个背包装物品，最多能装
 * 的价值是多少？
 *
 * 举例：
 * N = 3（3个物品），W = 4（背包容量4）
 * wt = [2, 1, 3]
 * val = [4, 2, 3]
 * 算法返回6 （选择前两件物品装进背包，总重量3小于W，可以获得最大价值6）
 *
 * 动态规划（Dynamic Programming）解题思路：
 *
 *  将「动态规划」的概念关键点抽离出来描述就是这样的：
 *    1.动态规划法试图只解决每个子问题一次
 *    2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。
 *
 * 一：明确【状态】和【选择】
 *
 *    明确状态：
 *    1：可选择的物品
 *    2：背包的容量
 *
 *    明确选择：
 *    1：物品装进背包
 *    2：物品不装进背包
 *
 *    得出伪代码
 * ```
 *    for 状态1 in 状态1的所有取值
 *      for 状态2 in 状态2的所有取值
 *        dp[状态1][状态2] = 选择(物品装进背包, 物品不装进背包)
 * ```
 *
 * 二：明确dp数组的定义
 *
 *    dp[0][w] = 0 （前0个物品，总价值肯定为0）
 *    dp[i][0] = 0 （容量为0，总价值肯定为0）
 *
 *    例如：
 *    dp[3][5] = 6, 对于所有物品，如果只对前三个进行选择，当背包容量为5的时候，最多能装下的价值是6
 *
 *    得出:
 *      对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是 dp[i][w]
 *
 *    套用参数，即：
 *    dp[N+1][W+1] = 总价值
 *
 *    N+1：因为dp数组下标为0的位置表示前0个物品，所以
 *      dp数组的长度 = 总物品数 + 1
 *    W+1：因为dp[x][0]表示容量为0，对于实际物品来说无意义，所以
 *      dp数组子数组长度 = 总总量 + 1
 *
 * ```
 *    let dp[N+1][W+1]
 *    dp[0][xxx] = 0
 *    dp[xxx][0] = 0
 *    for 状态1 in 状态1的所有取值
 *      for 状态2 in 状态2的所有取值
 *        dp[状态1][状态2] = 选择(把物品装进背包, 不装进背包)
 *
 *    return dp[N][W]
 *```
 *
 * 三：状态转移方程怎么写？
 *
 *    dp[i][w] 对于前i个物品，当前背包的容量为w，这种情况下可以装下的最大价值是dp[i][w]
 *
 *    1. 如果没有把第i个物品装进背包
 *
 *    dp[i][w] = dp[i-1][w]
 *
 *    2. 如果把第i个物品装进了背包
 *
 *    第i个物品的价值是 val[i-1]
 *    第i个物品的重量是 wt[i-1]
 *
 *    总价值 = 前i-1个物品的价值 + 第i个物品的价值
 *    dp[i][w] = dp[i-1][w-wt[i-1]] + val[i-1]
 *
 * ```
 *    for i in [1...N]
 *      fow w in [1...W]
 *        dp[i][w] = Math.max(
 *          dp[i-1][w],
 *          dp[i-1][w-wt[i-1]] + val[i-1]
 *        )
 * ```
 *
 * 四：把伪代码转换为代码
 */

/**
 * 0-1背包问题
 * @param W {number} 背包容量
 * @param N {number} 物品总数
 * @param wt {Array} 物品重量数组
 * @param val {Array} 物品价值数组
 * @returns Number 背包能装的最大价值
 */
function knapsack(W, N, wt = [], val = []) {
  const dp = Array.from(new Array(N + 1), () => new Array(W + 1).fill(0))

  for (let i = 1; i <= N; i++) {
    for (let w = 1; w <= W; w++) {
      if (w < wt[i - 1]) {
        dp[i][w] = dp[i - 1][w]
      } else {
        dp[i][w] = Math.max(
          dp[i - 1][w],
          dp[i - 1][w - wt[i - 1]] + val[i - 1]
        )
      }
    }
  }

  return dp[N][W]
}

const N = 6 // 物品数量
const W = 4 // 背包容量
const wt = [5, 2, 2, 1, 3, 1]
const val = [1, 1, 4, 2, 3, 5]

console.log(knapsack(W, N, wt, val))
