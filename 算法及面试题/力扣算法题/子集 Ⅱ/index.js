/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const subsetsWithDup = function(nums) {
  if (!Array.isArray(nums)) return nums

  // 当前已得到的子集（已去重）
  let arr = [[]]
  // 缓存每个数字出现次数
  let count = {}

  if (nums.length < 1) return arr

  // 依次遍历传入数组中的元素
  nums.forEach((num, i) => {
    count[num] = count[num] ? count[num] + 1 : 1
    // 区别于 上一题“子集”，这里需要去重
    // 去重思想：
    // 遍历nums数组，让nums[i]与当前已求得的子集数组的每一项求交集，
    // 求交集过程中，若nums[i]是首次出现，则肯定不会出现重复项
    // 若nums[i]不是首次出现，则肯定会出现重复项，
    //    在求交集过程中，检测求交集的arr的每一个子项，若num[i]不存在，则跳过该子项
    //    若nums[i]存在，则 比较nums[i]在该项出现的次数（x） 与 nums数组从num[0]到nums[i-1]，nums[i]出现的次数（y）
    //    若 x === y，则子项与nums[i]求交集，否则跳过
    // 然后把这个新得到的数组与求交集之前的子集数组合并即为新的子集数组

    // 举例论证：配图见 ./readme.md
    // 求数组[1,2,3,2]的子集
    // 定义一个数字与一个二维数组的交集：
    //    二维数组的每一个子数组依次添加该数字组成一个新的二维数组，例如数字2与二维数组[[],[1]]的交集为 [[2], [1, 2]]
    // nums数组从前往后依次遍历每一个元素nums[i], i为索引，
    // 假设arr表示当前循环已得到的子集，定义nums[i]
    // 把arr[n]看成nums中前n个元素的子集，得到：
    //    arr[n] = arr[n-1] + arr[n-1]与num[n-1]的交集，
    //    边界值：arr[0] = [[]], n >= 1
    // 穷举论证：
    //    当 i = 0 时，n = 1，nums[0] = 1, arr[1] = arr[0] + arr[0]与nums[0]的交集 = [[]] + [[1]] = [[], [1]]
    //    当 i = 1 时，n = 2，nums[1] = 2, arr[2] = arr[1] + arr[1]与nums[1]的交集 = [[], [1]] + [[2], [1, 2]] = [[], [1], [2], [1, 2]]
    //    当 i = 2 时，n = 3，nums[2] = 3, arr[3] = arr[2] + arr[2]与nums[2]的交集 = [[], [1], [2], [1, 2]] + [[3], [1, 3], [2, 3], [1, 2, 3]] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
    //    当 i = 3 时，n = 4，nums[3] = 2, arr[3] = arr[3] + arr[3]与nums[3]的交集 = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] + [[2], [1, 2], [2, 2], [1, 2, 2], [3, 2], [1, 3, 2], [2, 3, 2], [1, 2, 3, 2]] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]， [2], [1, 2], [2, 2], [1, 2, 2], [3, 2], [1, 3, 2], [2, 3, 2], [1, 2, 3, 2]]
    //      此时出现重复数字2，分析：
    //        arr[3]：                     [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
    //        arr[3]与nums[3]求交集的结果项：[[2], [1, 2], [2, 2], [1, 2, 2], [3, 2], [1, 3, 2], [2, 3, 2], [1, 2, 3, 2]]
    //        arr[3]与nums[3]求交集的结果项的重复项：[[2], [1, 2], [3, 2], [1, 3, 2]]，是与arr[3]中以下子项求交集得到：[[], [1], [3], [1, 3]]
    //        arr[3]与nums[3]求交集的结果项的不重复项：[[2, 2], [1, 2, 2], [2, 3, 2], [1, 2, 3, 2]]，是与arr[3]中以下子项求交集得到：[[2], [1, 2], [2, 3], [1, 2, 3]]
    //      结论：
    //        当求交集时，arr子项中存在重复数字，则求交集后的该子项必定不重复
    //        当求交集时，arr子项中不存在重复数字，则求交集后的该子项一定与其他子项重复（子项元素的顺序可能不同），
    //        以上值论证了重复一次的情况，若nums[i]不止重复一次，则要检测子项内重复数组的个数与nums[i]目前为止重复的次数

    // nums中的当前值与已得到的子级的副本的每一项结合，得到新的子集，然后将新子集与当前子集合并即为当前值
    let mixed = []
    for (let i = 0; i < arr.length; i++) {
      // 去重
      if (count[num] > 1) {
        if (arr[i].filter(value => value === num).length === count[num] - 1) {
          mixed.push([...arr[i], num])
        }

        continue
      }

      mixed.push([...arr[i], num])
    }

    arr = arr.concat(mixed)
  })

  return arr
}

console.log(subsetsWithDup([1, 2, 3, 2, 2]))
